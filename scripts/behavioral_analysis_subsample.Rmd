---
title: "Behavioral analysis"
author: "Sandra Martin & Pia Siegel"
date: "`r Sys.Date()`"
output: html_document:
  toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, echo=FALSE}
rm(list= ls()) # clear all 
knitr::opts_chunk$set()
options(scipen = 999)
```

# Load packages
```{r packages, message=FALSE, warning=TRUE}
library(here)
library(plyr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(lme4)
library(emmeans)
library(ggeffects)
library(stringr)
library(fitdistrplus)
library(see)
library(cowplot)
library(performance)
library(sjPlot)
```

```{r Theme for plots, include=FALSE}
apatheme <- theme_bw()+
  theme(plot.title = element_blank(), panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
        panel.border=element_blank(),axis.line=element_line(),
        text=element_text(family='sans',size=18)) #panel.grid.major=element_blank(),

today <- Sys.Date()
today <- format(today, format="%y%m%d")

palet_task <- c("#BBBBBB","#994455")
palet_task_cong <- c("#BBBBBB","#5D5D5D", "#994455", "#4d222b")

output_path = here::here("Plots/")

# creating a function for std.error
std.error <- function(x, na.rm = TRUE){sd(x, na.rm = TRUE)/sqrt(length(x[!is.na(x)]))}
```

# Load, clean and prepare data frame
## Load data
```{r}
# Load already filtered data frame (Drop outs: 4002, 3364, 2884, 2998, 3392, 3960, 3154, 3994, 4086, 2522 -> see R Markdown "data frame for analysis")
load(here::here("./RData/df_subsample_n41.RData"))
```

## Clean data
```{r}
# Additional drop out: Remove participant with ID = 4227 due to lack of understanding of the task (ALWAYS pressed correct (accuracy - incorrect: 0.0000000; accuracy - correct: 1.0000000))
df_subsample <- df_subsample[!df_subsample$ID == 4227, ]

# Remove NA values
df_subsample <- df_subsample[!is.na(df_subsample$response_time),]

# Remove RTs before picture was shown (equals rt = 0) and RTs below 200 ms
df_subsample <- df_subsample[!(df_subsample$response_time_absolute < df_subsample$time_picture),]
df_subsample <- df_subsample[!(df_subsample$response_time < 200),]

# Remove RTs that deviated more than 3 SD from the mean per participant, condition and run
outlier_df <- df_subsample %>% 
  group_by(ID, condition, run) %>% 
  mutate(outlier = ifelse(response_time > (mean(response_time) + 3*sd(response_time)), 1, 0))

n_outlier <- outlier_df %>% 
 group_by(ID, condition, run)  %>% 
 summarise(sum = sum(outlier))  

df_subsample <- df_subsample[outlier_df$outlier == 0, ]
```

## Prepare data frame 
```{r Prepare data frame}
# Make numeric variable for accuracy
df_subsample$accuracy_num <- ifelse(df_subsample$accuracy == "correct", 1, ifelse(df_subsample$accuracy == "incorrect", 0, NA))

## Create as well as calculate variable 'Weeks since Onset (WSO)'
# Define variables 'test' and 'onset' as dates
df_subsample$Test <- as.Date(df_subsample$Test, format = "%d.%m.%y")
df_subsample$Onset <- as.Date(df_subsample$Onset, format = "%d.%m.%y")

# Calculate 'WSO' and define variable as a numeric data type
df_subsample$WSO <- difftime(df_subsample$Test, df_subsample$Onset, units = "weeks")
df_subsample$WSO <- as.numeric(df_subsample$WSO)
```

## Prepare df for accuracy analysis
```{r}
# Create new data frame with relevant variables 
df_acc <- df_subsample[c('ID',
                         'run',
                         'accuracy_num')]

# Calculate mean of accuracy per run for each participant
df_acc_summary <- df_acc %>% 
  group_by(ID, run) %>% 
  mutate(average_accuracy = mean(accuracy_num)) %>% 
  dplyr::select(-accuracy_num) %>% 
  distinct()
 
# Define runs to exclude if participant performed at or below chance level
df_acc_summary <- df_acc_summary %>% 
  group_by(ID, run) %>% 
  filter(average_accuracy > 0.5) 

df_acc <- left_join(df_acc_summary, df_subsample, by = c("ID", "run"))
```

## Prepare df for reaction time analysis
```{r}
# remove incorrect answers
df_RT <- df_acc[df_acc$accuracy != "incorrect", ]

# Define variable "response time" as numeric
df_RT$response_time <- as.numeric(df_RT$response_time)
```

# Descriptive statistics - Plots
## Accuracy
```{r}
# relevel factors
df_acc$condition <- factor(df_acc$condition, levels = c("WPM", "FPM"))

# Create summary df for accuracy
summary_acc <- df_acc %>% 
  group_by(sub, condition, congruency) %>% 
  summarise(n_trials = n(), n_corr = sum(accuracy == "correct", na.rm = T), prop = sum(accuracy == "correct", na.rm = T)/n())

# Plot by Task
Acc_cond <- ggplot(summary_acc, aes(x = condition, y = prop*100, fill = condition)) +
  geom_violinhalf(aes(fill = condition), position = position_nudge(x = 0.2, y = 0), alpha = 0.6, color = NA) +
  geom_boxplot(alpha = 1, width = .3, colour = "black", outlier.shape = NA, position = position_dodge(width = 0.4)) +
  scale_colour_manual(values =palet_task, labels = c("WPM", "FPM")) + 
  scale_fill_manual(values = palet_task, labels = c("WPM", "FPM")) +
  labs(y = "Accuracy in %") +
  apatheme +
  theme(legend.position=("none"), 
        legend.title=element_blank(), 
        legend.text=element_text(size=12),
        axis.title.x = element_blank()) + 
 facet_wrap(~ congruency)
 quartz(12,10,) # works only for macOS
Acc_cond
save_plot(Acc_cond, file = here::here(paste0("Plots/Acc_cond_", today, ".pdf")))
```

## Reaction time 
```{r}
# relevel factors
df_RT$condition <- factor(df_RT$condition, levels = c("WPM", "FPM"))

# Create summary df for RT data
summary_rt_full <- df_RT %>% group_by(condition, congruency) %>% 
  summarise(mean_rt = mean(response_time, na.rm = TRUE), 
            md_rt = median(response_time, na.rm = TRUE),
            SD_rt = sd(response_time, na.rm = TRUE), 
            var_rt = var(response_time, na.rm = TRUE),
            std.error_rt = std.error(response_time, na.rm = TRUE))

# Plot by Task
RT_cond <- ggplot(df_RT, aes(x = condition, y = response_time, fill = condition)) + 
  geom_violinhalf(aes(fill = condition), position = position_nudge(x = .2, y = 0), adjust = 1.5, trim = FALSE, alpha = .6, colour = NA) +
  geom_boxplot(alpha = 1, width = .3, colour = "black", outlier.shape = NA, position = position_dodge(width = 0.4)) +
  scale_colour_manual(values =palet_task, labels = c("WPM", "FPM")) + 
  scale_fill_manual(values = palet_task, labels = c("WPM", "FPM")) +
  labs(y = "Reaction time in ms") +
  apatheme +
  theme(legend.position=("none"), 
        legend.title=element_blank(), 
        legend.text=element_text(size=12),
        axis.title.x = element_blank()) + 
  facet_wrap(~ congruency)
  quartz(12,10,) # works only for macOS
RT_cond

save_plot(RT_cond, file = here::here(paste0("Plots/RT_cond_", today, ".pdf")))
```

# RT analysis
## Mixed-effects regression
### Describe distribution of RT and check if log-transformation is good
```{r Describe distribution of RT}
descdist(df_RT$response_time)
descdist(log(df_RT$response_time)) # log-transform leads to perfect normal dist
lattice::densityplot(log(df_RT$response_time))
```

### Model
```{r RT - Model including baseline session}
# relevel factors
df_RT$condition <- factor(df_RT$condition, levels = c("WPM", "FPM"))
df_RT$congruency <- factor(df_RT$congruency, levels = c("congruent", "incongruent"))
df_RT$age_z <- scale(df_RT$Age, scale = T)
df_RT$lesion_volume_z <- scale(df_RT$Lesion_volume, scale = T)
df_RT$WSO_z <- scale(df_RT$WSO, scale = T)

#---- Simple coding ----
# create a Simple Coding scheme
# https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/
# creating the contrast matrix manually by modifying the dummy coding scheme
c <- contr.treatment(2)
my.coding <- matrix(rep(1/2, 2), ncol = 1) 
my.simple <- c-my.coding

#assign the new coding scheme
contrasts(df_RT$condition) <- my.simple
contrasts(df_RT$congruency) <- my.simple

# ---- fit model ----
m_RT <- lmer(log(response_time) ~ condition * congruency + run + lesion_volume_z + age_z + WSO_z + (1+ run + condition * congruency|sub) + (1|stimulus_audio) + (1|stimulus_picture), data = df_RT, REML = F, lmerControl(optimizer = "bobyqa"))

save(m_RT, file = here::here(paste0("RData/m_RT_", today, ".RData")))

summary(m_RT)

m_RT_res <- drop1(m_RT1, test = "Chisq")
save(m_RT_res, file = here::here(paste0("RData/m_RT_res", today, ".RData")))

# explore interaction
RT_emm <- emmeans(m_RT1, pairwise ~ congruency | condition, adjust = "holm", type = "response")

# plot model results
RT_int <- plot(ggemmeans(m_RT1, terms = c("condition")), collapse_group = c("run", "sub")) +
  scale_colour_manual(values = palet_task) +
  ylab("Reaction time in ms") +
  apatheme +
  theme(axis.title.x = element_blank(),
        legend.position = "none",
        legend.title = element_blank(),
        legend.text=element_text(size=10))
RT_int
save_plot(RT_int, file = here::here(paste0("Plots/m_RT_cond_cong_", today, ".png")))

RT_lesionVol <- plot(ggemmeans(m_RT1, terms = c("lesion_volume_z")), limit.range = T) +
  ylab("Reaction time in ms") +
  xlab("Standardized lesion volume") +
  apatheme +
   theme(legend.position = "none",
        legend.title = element_blank())
RT_lesionVol
save_plot(RT_lesionVol, file = here::here(paste0("Plots/m_RT_lesionVol_", today, ".pdf")))

RT_run <- plot(ggemmeans(m_RT1, terms = c("run"))) +
  ylab("Reaction time in ms") +
  xlab("Run") +
  apatheme +
   theme(legend.position = "none",
        legend.title = element_blank())
RT_run
save_plot(RT_run, file = here::here(paste0("Plots/m_RT_run_", today, ".pdf")))

#---- create table output for model
tab_model(m_RT1)
```

# Accuracy analysis
## Mixed-effects regression
### Model
```{r Accuracy - Model}
# relevel factors
df_behav$condition <- factor(df_behav$condition, levels = c("WPM", "FPM"))
df_behav$congruency <- factor(df_behav$congruency, levels = c("congruent", "incongruent"))
df_behav$age_z <- scale(df_behav$Age, scale = T)
df_behav$Lesion_volume_z <- scale(df_behav$Lesion_volume, scale = T)

#---- Simple coding ----
# create a Simple Coding scheme
# https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/
# creating the contrast matrix manually by modifying the dummy coding scheme
c <- contr.treatment(2)
my.coding <- matrix(rep(1/2, 2), ncol = 1) 
my.simple <- c-my.coding

#assign the new coding scheme
contrasts(df_behav$condition) <- my.simple
contrasts(df_behav$congruency) <- my.simple

df_behav <- df_behav %>% 
  mutate(correct = case_when(
    accuracy == "correct" ~ 1,
    accuracy == "incorrect" ~ 0
  ))
df_behav$correct <- as.factor(df_behav$correct)

# ---- fit model ----
m_acc <- glmer(correct ~ condition * congruency + run + Lesion_volume_z + (1 + run + condition + congruency|sub) + (1|stimulus_audio) + (1|stimulus_picture), data = df_behav, family = binomial(link = "logit"), glmerControl(optimizer = "bobyqa")) # model with interaction in random slopes is singular

save(m_acc, file = here::here(paste0("RData/m_acc_", today, ".RData")))

summary(m_acc)

m_acc_res <- drop1(m_acc1, test = "Chisq")
save(m_acc_res, file = here::here(paste0("RData/m_acc_res", today, ".RData")))

## explore direction of interaction
acc_emm <- emmeans(m_acc1, pairwise ~ congruency | condition, adjust = "holm")

## plot model output
Acc_int <- plot(ggemmeans(m_acc1, terms = c("condition", "congruency"))) +
  scale_colour_manual(values = palet_task) +
  coord_cartesian(ylim = c(0.5, 1)) +
  ylab("Accuracy") +
  apatheme +
  theme(axis.title.x = element_blank(),
        legend.position = "bottom",
        legend.title = element_blank(),
        legend.text=element_text(size=10))
Acc_int
save_plot(Acc_int, file = here::here(paste0("Plots/m_Acc_cond_cong_", today, ".pdf")))
```